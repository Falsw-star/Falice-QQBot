# 触发器类型

在Falice中，插件的运行逻辑是触发器(triggers)。在用`load_trigger()`加载触发器的时候需要传入一个类型(`type`参数)。触发器有不同的类型，比如匹配命令的`cmd`。下面我会介绍这些类型。同时需要明确，下面将多次提到触发器加载时必须传入的另一个参数`trigger`，这个参数将会指定该触发器匹配的消息具体内容（下面会做解释）。

***

### 对于以下的触发器类型，其`func`参数所包含的函数必须一前一后接收两个参数`msg`和`special_content`。

### all

`all`类型的触发器将会在收到任何消息时触发，不管消息是什么类型。其`special_content`为空。

`all`类型的触发器的`trigger`也是必须传入的，但是可以随便传入，比方说`"我是一个玉米啦啦啦"`，只要是字符串就好啦。

### cmd

`cmd`类型的触发器将对以“/”+`trigger`开头的消息进行匹配和解析。比如，消息“/test”将会触发一个`type`为`cmd`,`trigger`为`"test"`的触发器。

cmd触发器的`special_content`是一个列表，里面包含以空格作为分割的命令的参数。比如，消息“/test 114514 1919810 我是第三个参数”若是触发了上述触发器，那么`special_content`将会是`["114514", "1919810", "我是第三个参数"]`。你可以根据需要对其解析，如判断参数是否存在、一共有几个参数等。

### start

`start`类型的触发器将会在收到以`trigger`开头的消息时触发。比如，消息“我爱着这个世界”将会触发一个`type`为`start`,`trigger`为`"我爱着"`的触发器，而“我爱这个世界”则不会触发该触发器。

`start`触发器的`special_content`为空。

### end

`end`类型的触发器将会在收到以`trigger`结尾的消息时触发。比如，消息“宇宙是仁慈的”将会触发一个`type`为`end`,`trigger`为`"仁慈的"`的触发器，而“宇宙很仁慈”则不会触发该触发器。

`end`触发器的`special_content`为空。

### keyword

`keyword`类型的触发器将会在收到包含`trigger`的消息时触发。比如，消息“它梦见了阳光和树”将会触发一个`type`为`keyword`,`trigger`为`"阳光"`的触发器，而“它梦见了日光和树”则不会触发该触发器。

### 我的消息究竟会触发哪些触发器？/ 消息可能触发多个触发器？

首先，`all`类型的触发器无论在什么情况下都会被触发。并且实际上`all`类型触发器的`block`参数是无效的。

有时候一条消息会触发多个触发器。比如，消息“/我今天吃了114514根玉米”将会同时触发一个`type`为`cmd`、`trigger`为`我`的触发器，一个`type`为`keyword`、`trigger`为`"114514"`的触发器和一个`type`为`end`、`trigger`为`"玉米"`的触发器。

Falice对各个触发器的匹配顺序进行了限制。如果一个`block`为`True`的触发器被触发，那么触发器匹配到此结束，其他的触发器不会被触发。

一般来讲（指我不知道有没有bug），匹配顺序为：

第一层(匹配`type`)：`cmd`、`start`、`end`、`keyword`。

第二层(在每个`type`内)：按照在clock.py中对每个插件运行`loads()`的先后。

第三层(在每个插件内)：按照`load_trigger`加载触发器的顺序。

（匹配顺序可能有些难理解，但是总之就是这么一回事。）

根据匹配顺序设置`block`，可以在一定程度上帮到你。如果我有时间写一个优先级系统的话就更好了。

***

### service

`service`类型的触发器会在每个主时钟循环（默认1s）触发一次。它的特殊性在于该类型的触发器会主动地、非常频繁地触发，并且不受以上触发器的影响。

同时，`service`类型的触发器被`load_trigger`加载时需求的`func`有些特殊，你所传入的函数不需要接收任何参数（因为没有参数可以给你），这点与以上触发器的`func`需要接收两个参数不同。

`service`触发器在一些情况下被用到。比如利用判断当前时间来实现定时发送。

***